## 1. useEffect Hook

> 화면에 보여지는 리액트 컴포넌트에 특정 작업을 할 수 있고, props나 상태가 변경되서 업데이트 될 때도 작업이 가능. 리랜더링 될 때마다 어떤 작업을 등록 가능.

#### useEffect() 함수에서 deps가 없는 경우

```js
// UserList.js

import React, { useEffect } from 'react';

function User({ user, onRemove, onToggle }) {
  const { username, email, id, active } = user;

  useEffect(() => {
    console.log('컴포넌트가 화면에 나타남');
    // 두번째 parameter는 배열을 넣어주는데, 이 배열을 deps라고 부른다. dependency라는 뜻.
    // 의존되는 값들을 배열안에 넣어주면 된다. 비어있으면 컴포넌트가 처음 화면에 나타날 때만
    // 실행이 된다.
    return () => {
      console.log('컴포넌트가 화면에서 사라짐');
      // 클리너 함수를 뒷정리 함수라고도 부른다.
    };
  }, []);
  return (
    <div>
      <b
        style={{
          color: active ? 'green' : 'black',
          cursor: 'pointer',
        }}
        onClick={() => onToggle(id)}
      >
        {username}
      </b>
      &nbsp;
      <span>({email})</span>
      <button onClick={() => onRemove(id)}>삭제</button>
    </div>
  );
}

function UserList({ users, onRemove, onToggle }) {
  //
  return (
    <div>
      {users.map((user) => (
        <User
          user={user}
          key={user.id}
          onRemove={onRemove}
          onToggle={onToggle}
        />
      ))}
    </div>
  );
}

export default UserList;
```

---

#### 컴포넌트가 마운트 될 때, 주로 추가하는 작업은...

- props로 받은 값을 컴포넌트의 state로 설정
- REST API, 외부 API요청, 특정 API요청할 때,
- D3, Video.js 등의 라이브러리 사용할 때,

- setInterval, setTimeout  등의 작업

> useEffect에서 함수가 호출되는 시점에서는, UI가 화면에 나타난 상태 이후다.
>
> 그래서, DOM에 바로 접근해도 된다.

#### 컴포넌트가 언마운트 될 때, 주로 하는 작업은...

- clearInterval, clearTimeout 등의 작업
- 라이브러리 인스턴스 제거

---



#### useEffect() 함수에서 deps가 있는 경우

```js
// UserList.js

import React, { useEffect } from 'react';

function User({ user, onRemove, onToggle }) {
  const { username, email, id, active } = user;

  useEffect(() => {
    console.log('user값이 설정됨');
    console.log(user);
    return () => {
      console.log('user값이 바뀌기 전');
      console.log(user);
    };
  }, [user]);
  // useEffect의 함수는, deps값인 [user]가 설정되거나 변경될 때마다 호출이 된다.
  // 처음 화면에 나타날 때에도 호출이 된다는 것을 알고있자.
  // useEffect 함수에서 props로 받아온 값을 참조하거나, useState로 관리하고 있는 값을
  // 참조하고 있는 경우에는 deps배열을 꼭 넣어주어야 한다.
  // 넣지 않으면 오류가 나진 않지만, 경고가 뜬다.

  return (
    <div>
      <b
        style={{
          color: active ? 'green' : 'black',
          cursor: 'pointer',
        }}
        onClick={() => onToggle(id)}
      >
        {username}
      </b>
      &nbsp;
      <span>({email})</span>
      <button onClick={() => onRemove(id)}>삭제</button>
    </div>
  );
}

function UserList({ users, onRemove, onToggle }) {
  //
  return (
    <div>
      {users.map((user) => (
        <User
          user={user}
          key={user.id}
          onRemove={onRemove}
          onToggle={onToggle}
        />
      ))}
    </div>
  );
}

export default UserList;

```

---

---



## 2. useMemo Hook

> 이전에 연산된 값을 재사용하는 방법
>
> 주로, 성능을 최적화해야 하는 경우에 사용한다

#### useMemo를 사용하지 않았을 경우

![image-20200916142915945](11.Hook_Functions.assets/image-20200916142915945.png)

- {name, value} 를 가져와서 input 상태를 바꾸고 있는데, onChange 이벤트를 발생시켜도 컴포넌트는 리랜더링 된다. 그래서, 리랜더링이 될 때마다 활성 사용자 수를 센다. (불필요한 동작)
- 이럴때 사용할 수 있는게 useMemo이다.
- 특정 값이 바뀌었을 때만 특정 함수를 실행해서 연산하도록 처리하고, 원하는 값이 변경되지 않았다면 이전에 만들어놨던 값을 재사용 할 수 있게 해준다.

---

#### useMemo를 사용한 경우

![image-20200916144337554](11.Hook_Functions.assets/image-20200916144337554.png)

- 리랜더링이 돼도 불필요한 호출은 하지 않는다.

---
---



## useCallback Hook

> 이전에 만들었던 함수를 새로 만들지않고 재사용 할 수 있다.
>
> useMemo랑 비슷하지만 함수를 위한 hook이다.

```js
// App.js

import React, { useRef, useState, useMemo } from 'react';
import CreateUser from './CreateUser';
import UserList from './UserList';

function countActiveUsers(users) {
  //
  console.log('활성 사용자 수를 세는중...')
  return users.filter(user => user.active).length;
}

function App() {
  //
  const [inputs, setInputs] = useState({
    username: '',
    email: '',
  });
  const { username, email } = inputs;
  const onChange = e => {
    const { name, value } = e.target;
    setInputs({
      ...inputs,
      [name]: value
    });
  };

  const [users, setUsers] = useState([
    {
      id: 1,
      username: 'HJ',
      email: 'hyukjin4976@naver.com',
      active: true,
    },
    {
      id: 2,
      username: 'Steve',
      email: 'stevej0717@gmail.com',
      active: false,
    },
    {
      id: 3,
      username: 'HyukJin',
      email: 'wjdgurwls3784@hanmail.com',
      active: false,
    },
  ]);

  const nextId = useRef(4);

  const onCreate = () => {
    const user = {
      id: nextId.current,
      username,
      email,
    }

    setUsers(users.concat(user))

    setInputs({
      username: '',
      email: ''
    })
    console.log(nextId.current);
    nextId.current += 1;
  }

  const onRemove = id => {
    //
    setUsers(users.filter(user => user.id !== id));
  }

  const onToggle = id => {
    setUsers(users.map(user => user.id === id ? { ...user, active: !user.active } : user));
  }

  const count = useMemo(() => countActiveUsers(users), [users]);

  return (
    <>
      <CreateUser
        username={username}
        email={email}
        onChange={onChange}
        onCreate={onCreate} />
      <UserList users={users} onRemove={onRemove} onToggle={onToggle} />
      <div>활성 사용자 수: {count} </div>
    </>

  );
}

export default App;

```

- 위에 함수들을 보면 컴포넌트가 리랜더링 될 때마다 새로운 함수를 만들고 있다.
- 함수를 새로 만드는 것 자체는 메모리와 cpu가 리소스를  많이 차지하는 작업은 아니지만, 한 번 만든 함수는 재사용할 수 있다면 하는 것이 좋다. 그 이유는, 컴포넌트들이 props가 바뀌지 않았다면 Virtual DOM에서 하는 리랜더링조차 안하게끔 만들어 줄 수 있다. 
- 하지만, 그 작업을 하려면 위처럼 매번 함수가 새로 만들어지는 구조면 최적화를 하지 못한다. 

![image-20200916150850666](11.Hook_Functions.assets/image-20200916150850666.png)

- 왼쪽 함수를 오른쪽 함수로 바꿔준다.

- username, email 같은 경우는 input에서 바깥으로 빼내준 값이지만 결국 상태이기 때문에, deps배열에 넣어주어야 한다.
- 만약 넣지 않는다면, 함수 내부에서 해당 상태들을 참조하게 될 때, 가장 최신 상태를 참조하지 않고, 처음 만들어질 때의 컴포넌트 상태를 참조하게 된다.
- useCallback 내부에서 참조하게 되는 상태나 props로 받아온 값이 있다면, deps배열에 꼭 넣어주어야 한다.
- 함수를 props로 받아와도 똑같이 해줘야 한다.

---

---

